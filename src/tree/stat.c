/*************************************************************************\
 *                                                                       *
                  last updated on 2016/12/06(Tue) 12:57:52
 *                                                                       *
 *    Constructing octree structure for collisionless systems            *
 *                                                                       *
 *                                                                       *
 *                                                                       *
 *                                             written by Yohei MIKI     *
 *                                                                       *
\*************************************************************************/
//-------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
//-------------------------------------------------------------------------
#include "macro.h"
//-------------------------------------------------------------------------
#include "make.h"
#include "stat.h"
//-------------------------------------------------------------------------


//-------------------------------------------------------------------------
void setSubRootNode(uint *more_hst, int *subrootNum, int subrootIdx[restrict])
{
  //-----------------------------------------------------------------------
  __NOTE__("%s\n", "start");
  //-----------------------------------------------------------------------

  //-----------------------------------------------------------------------
  const uint root = more_hst[0];
  //-----------------------------------------------------------------------
#ifdef  DEEPER_SPLIT_MODE
  //-----------------------------------------------------------------------
  const int rootNum  = (int)(1 + (root >> IDXBITS));
  const int rootHead = (int)(     root  & IDXMASK );
  *subrootNum = 0;
  for(int ii = 0; ii < rootNum; ii++){
    //---------------------------------------------------------------------
    const uint cell = more_hst[rootHead + ii];
    const int num  = (int)(1 + (cell >> IDXBITS));
    const int head = (int)(     cell  & IDXMASK );
    //---------------------------------------------------------------------
    for(int jj = 0; jj < num; jj++)
      subrootIdx[*subrootNum + jj] = head + jj;
    *subrootNum += num;
    //---------------------------------------------------------------------
  }
  //-----------------------------------------------------------------------
#else//DEEPER_SPLIT_MODE
  //-----------------------------------------------------------------------
  *subrootNum    = (int)(1 + (root >> IDXBITS));
  const int head = (int)(     root  & IDXMASK );
  for(int ii = 0; ii < *subrootNum; ii++)
    subrootIdx[ii] = head + ii;
  //-----------------------------------------------------------------------
#endif//DEEPER_SPLIT_MODE
  //-----------------------------------------------------------------------

  //-----------------------------------------------------------------------
  __NOTE__("%s\n", "end");
  //-----------------------------------------------------------------------
}
//-------------------------------------------------------------------------


//-------------------------------------------------------------------------
#if 0
//-------------------------------------------------------------------------
void chkHierarchyStatistics
(const int Ngrp, igroup * restrict ikey_info,
 int * restrict ilevel, uint * restrict ptag,
 uint * restrict parent, uint * restrict children, PHint * restrict cellKey,
 int * restrict ctag,
 float *tolerance,
 uint subrootCell[restrict], uint subrootNode[restrict])
{
  //-----------------------------------------------------------------------
  __NOTE__("%s\n", "start");
  //-----------------------------------------------------------------------


  //-----------------------------------------------------------------------
  /* examine statistics of Peano--Hilbert key hierarchy */
  //-----------------------------------------------------------------------
  /* initialize statistics of PH-key hierarchy */
  float mean = 0.0f;
  float disp = 0.0f;
  //-----------------------------------------------------------------------
  /* examine all leaf cells */
  for(int ii = 0; ii < Ngrp; ii++){
    //---------------------------------------------------------------------
    ikey_info[ii].level  = MAXIMUM_PHKEY_LEVEL;
    ikey_info[ii].repIdx = 0;
    const int head = ikey_info[ii].idxBody;
    const int tnum = ikey_info[ii].numTrue;
    //---------------------------------------------------------------------
    for(int jj = head; jj < head + tnum; jj++){
      //-------------------------------------------------------------------
      const int ilev = ilevel[jj];
      //-------------------------------------------------------------------
      /* smaller value of keys indicates deeper level of tree cells */
      if( ikey_info[ii].level > ilev ){
	ikey_info[ii].level  = ilev;
	ikey_info[ii].repIdx = jj;
      }
      //-------------------------------------------------------------------
    }
    //---------------------------------------------------------------------
    const float flev = (float)ikey_info[ii].level;
    //---------------------------------------------------------------------
    mean +=        flev;
    disp += flev * flev;
    //---------------------------------------------------------------------
  }
  //-----------------------------------------------------------------------
  mean /= (float)Ngrp;
  disp /= (float)Ngrp;
  disp -= mean * mean;
  disp = sqrtf(disp);
  //-----------------------------------------------------------------------

  //-----------------------------------------------------------------------
  const int elder =      children[0]  & IDXMASK;
  const int num   = 1 + (children[0] >> IDXBITS);/* normally, num should be eight */
  for(int ii = 0; ii < num; ii++){
    subrootCell[ii] = elder + ii;
    subrootNode[ii] = ptag[subrootCell[ii]];
  }
  //-----------------------------------------------------------------------


  //-----------------------------------------------------------------------
  /* static PHint subrootKey[8]; */
  static PHint subrootKey[NLEAF];
  for(int ii = 0; ii < num; ii++){
    subrootKey[ii] = cellKey[subrootCell[ii]];
  }
  //-----------------------------------------------------------------------
  /* 63 bits = 3 * 21 bits = 21 unities */
  /* only the last 3 * MAXIMUM_PHKEY_LEVEL bits are necessary */
  static const PHint maskUnit = 0111111111111111111111 >> (3 * (21 - MAXIMUM_PHKEY_LEVEL));
  //-----------------------------------------------------------------------


  //-----------------------------------------------------------------------
  /* pick up i-particles which locate in high-density peaks */
  //-----------------------------------------------------------------------
#ifdef  SPLIT_TREE_TRAVERSAL
  if( (*tolerance) * disp > mean )
    *tolerance = 0.5f * (mean / disp);
  const int crit = (int)(mean - disp * (*tolerance));
#endif//SPLIT_TREE_TRAVERSAL
  //-----------------------------------------------------------------------
  for(int ii = 0; ii < Ngrp; ii++){
    //---------------------------------------------------------------------
    int level = ikey_info[ii].level;
    ikey_info[ii].numRoot = (level < crit) ? (num) : (1);
    //---------------------------------------------------------------------
    if( ikey_info[ii].numRoot == num ){
      //-------------------------------------------------------------------
      /* set the grandparent cell as a candidate for the root cell */
      const  int pidx = ikey_info[ii].repIdx;
      const  int cidx = ctag[pidx];
      const uint root = parent[parent[cidx]];/* index of the grandparent cell for the representative leaf cell */
      level += 2;
      //-------------------------------------------------------------------
      /* if the candidate root cell is sufficiently close to the true root cell, then normal tree traversal should be performed */
      if( root == NULL_CELL ){
	ikey_info[ii].numRoot = 1;
	break;
      }
      //-------------------------------------------------------------------

      //-------------------------------------------------------------------
      /* set candidates for root cell to traverse tree cells */
      //-------------------------------------------------------------------
      const PHint rkey = cellKey[root];
      const   int shift = 3 * ((MAXIMUM_PHKEY_LEVEL - 1) - level - 1);
      //-------------------------------------------------------------------
      static  uint tmpRoot[NLEAF];
      static PHint    goal[NLEAF];
      static bool     seek[NLEAF];
      for(int jj = 0; jj < num; jj++){
	//-----------------------------------------------------------------
	const PHint temp = subrootKey[jj] ^ (rkey >> shift);
	//-----------------------------------------------------------------

	//-----------------------------------------------------------------
	/* if the candidate cell and the representative i-particle locate in the different box, tree traversal must be performed */
	//-----------------------------------------------------------------
	tmpRoot[jj] = subrootCell[jj];
	goal   [jj] = rkey ^ (temp * (maskUnit >> (3 * (level + 1))));
	seek   [jj] = true;
	//-----------------------------------------------------------------
      }
      //-------------------------------------------------------------------


      //-------------------------------------------------------------------
      /* find root cells by width-first tree traversal */
      //-------------------------------------------------------------------
      for(int clev = MAXIMUM_PHKEY_LEVEL - 2; clev > level; clev--){
	//-----------------------------------------------------------------
	const  int diff = 3 * (clev - level - 1);
	//-----------------------------------------------------------------
	for(int jj = 0; jj < num; jj++){
	  //---------------------------------------------------------------
	  if( seek[jj] ){
	    //-------------------------------------------------------------
	    const PHint compare = goal[jj] >> diff;
	    //-------------------------------------------------------------
	    const uint father = tmpRoot[jj];
	    const uint  child = children[father];
	    //-------------------------------------------------------------
	    if( child != NULL_CELL ){
	      //-----------------------------------------------------------
	      const int sonHead =      child &  IDXMASK;
	      const int sonNum  = 1 + (child >> IDXBITS);
	      //-----------------------------------------------------------
	      for(int sonIdx = sonHead; sonIdx < sonHead + sonNum; sonIdx++){
		//---------------------------------------------------------
		const PHint sonKey = cellKey[sonIdx];
		//---------------------------------------------------------
		if( sonKey == compare ){
		  //-------------------------------------------------------
		  tmpRoot[jj] = sonIdx;
		  break;
		  //-------------------------------------------------------
		}
		//---------------------------------------------------------
		if( sonIdx == (sonHead + sonNum - 1) ){
		  //-------------------------------------------------------
		  /* candidate root cell is missing */
		  ikey_info[ii].idxRoot[jj] = ptag[father];
		  seek[jj] = false;
		  //-------------------------------------------------------
		}
		//---------------------------------------------------------
	      }
	      //-----------------------------------------------------------
	    }
	    //-------------------------------------------------------------
	    else{
	      //-----------------------------------------------------------
	      /* candidate root cell is missing */
	      ikey_info[ii].idxRoot[jj] = ptag[father];
	      seek                 [jj] = false;
	      //-----------------------------------------------------------
	    }
	    //-------------------------------------------------------------
	  }
	  //---------------------------------------------------------------
	}
	//-----------------------------------------------------------------
      }
      //-------------------------------------------------------------------
      for(int jj = 0; jj < num; jj++){
	//-----------------------------------------------------------------
	if( seek[jj] ){
	  ikey_info[ii].idxRoot[jj] = ptag[tmpRoot[jj]];
	}
	//-----------------------------------------------------------------
      }
      //-------------------------------------------------------------------
    }
    //---------------------------------------------------------------------
  }
  //-----------------------------------------------------------------------


  //-----------------------------------------------------------------------
  __NOTE__("%s\n", "end");
  //-----------------------------------------------------------------------
}
//-------------------------------------------------------------------------
#endif
//-------------------------------------------------------------------------
