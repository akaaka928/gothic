/*************************************************************************\
 *                                                                       *
                  last updated on 2015/12/14(Mon) 16:36:46
 *                                                                       *
 *    Multipole Acceptance Criterion based on Warren & Salmon (1993)     *
 *                                                                       *
 *                                                                       *
 *                                                                       *
 *                                             written by Yohei MIKI     *
 *                                                                       *
\*************************************************************************/
//-------------------------------------------------------------------------
/* see augustus:~/Dropbox/documents/scan/2014-07-09wsmac.pdf */
//-------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
//-------------------------------------------------------------------------
#include <macro.h>
//-------------------------------------------------------------------------
#include "../sort/peano.h"
//-------------------------------------------------------------------------
#include "macutil.h"
#include "make.h"
//-------------------------------------------------------------------------


//-------------------------------------------------------------------------
#ifndef WS93_MAC
static real theta_bhtree;
void setGlobalConstants_macutil_c(const real preset){  theta_bhtree = preset;}
#endif//WS93_MAC
//-------------------------------------------------------------------------


//-------------------------------------------------------------------------
#ifdef  WS93_MAC
//-------------------------------------------------------------------------
/* estimate approximated opening criterion theta using bisection method */
//-------------------------------------------------------------------------
static inline real eqnAppTheta(const real theta, const int pp, const real delta, const real appForce)
{
  //-----------------------------------------------------------------------
  real ans = appForce * (real)(pp + 2);
  for(int ii = 0; ii < pp + 3; ii++)
    ans *= theta;
  ans -= delta * (theta - UNITY) * (theta - UNITY);
  //-----------------------------------------------------------------------
  return (ans);
  //-----------------------------------------------------------------------
}
//-------------------------------------------------------------------------
static inline real getAppTheta(const int pp, const real delta, const real appForce)
{
  //-----------------------------------------------------------------------
  real xl =  ZERO;  real fl = eqnAppTheta(xl, pp, delta, appForce);
  real xr = UNITY;  real fr = eqnAppTheta(xr, pp, delta, appForce);
  if( fl * fr > ZERO ){
    __KILL__(stderr, "ERROR: fl = %e and fr = %e\n", fl, fr);
  }
  //-----------------------------------------------------------------------
  real xc;
  for(int steps = 0; steps < 16; steps++){
    //---------------------------------------------------------------------
    xc = HALF * (xl + xr);
    real fc = eqnAppTheta(xc, pp, delta, appForce);
    //---------------------------------------------------------------------
    /* __NOTE__("theta = %e after %u iterations\n", xc, steps); */
    //---------------------------------------------------------------------
    if( FABS(fc) < EPSILON )      return (xc);
    if( fl * fc < ZERO ){      xr = xc;      fr = fc;    }
    else{                      xl = xc;      fl = fc;    }
    //---------------------------------------------------------------------
  }
  //-----------------------------------------------------------------------
  return (xc);
  //-----------------------------------------------------------------------
}
//-------------------------------------------------------------------------
/* estimate approximated force Mj / bmax^2 */
//-------------------------------------------------------------------------
static inline real getAppForce(const int Ni, const int Nlev)
{
  //-----------------------------------------------------------------------
  real root = UNITY;
  real leaf = (real)NCRIT / (real)Ni;
  //-----------------------------------------------------------------------
  for(int ii = 0; ii < Nlev; ii++){
    root *= HALF;
    leaf *= FOUR;
  }
#if 1
  /* 2 / 3 = (NCRIT / Ni) * 2 ^ (2 * Nlev) @ Nlev = (log2(Ntot / NCRIT)) / 3, which means uniformly distributed particles fill whole cells */
  if( leaf > EPSILON + TWO * ONE_THIRD )
    leaf = TWO * ONE_THIRD;
#endif
  //-----------------------------------------------------------------------
  return ((root > leaf) ? (root) : (leaf));
  //-----------------------------------------------------------------------
}
//-------------------------------------------------------------------------
#endif//WS93_MAC
//-------------------------------------------------------------------------


//-------------------------------------------------------------------------
/* count # of tree cells required */
//-------------------------------------------------------------------------
static inline int getNumLeaf(const int Nlev, const real theta, const int numRoot)
{
  //-----------------------------------------------------------------------
  const int invTheta = (int)(CEIL(UNITY / ((real)1.0e-30 + theta)));
  //-----------------------------------------------------------------------
  int numLeaf;
#ifdef  WS93_MAC
  if( invTheta < Nlev )
#else///WS93_MAC
  if( invTheta < Nlev - 2 )
#endif//WS93_MAC
    {
      numLeaf  = (1 + 2 * invTheta);
      numLeaf *= (numLeaf * numLeaf);
    }
  else
    numLeaf = numRoot;
  //-----------------------------------------------------------------------
  return (numLeaf);
  //-----------------------------------------------------------------------
}
//-------------------------------------------------------------------------


//-------------------------------------------------------------------------
/* estimate required size for bufSize */
//-------------------------------------------------------------------------
void getBufSize
(
#ifdef  WS93_MAC
 const int pp, const real delta, const int Ni,
#endif//WS93_MAC
 int *bufSize
)
{
  //-----------------------------------------------------------------------
  __NOTE__("%s\n", "start");
  //-----------------------------------------------------------------------

  //-----------------------------------------------------------------------
  *bufSize = 0;
  int numRoot = 1;
  //-----------------------------------------------------------------------
#ifndef WS93_MAC
  const real appTheta = theta_bhtree;
#endif//WS93_MAC
  //-----------------------------------------------------------------------
  for(int Nlev = 0; Nlev < MAXIMUM_PHKEY_LEVEL; Nlev++){
    //---------------------------------------------------------------------
#ifdef  WS93_MAC
    const real appTheta = getAppTheta(pp, delta, getAppForce(Ni, Nlev));
#endif//WS93_MAC
    //---------------------------------------------------------------------
    int numLeaf = getNumLeaf(Nlev, appTheta, numRoot * 8);
    if( (*bufSize) < (numRoot + numLeaf) )
      *bufSize = numRoot + numLeaf;
    //---------------------------------------------------------------------
    numRoot = numLeaf;
    //---------------------------------------------------------------------
  }
  //-----------------------------------------------------------------------

  //-----------------------------------------------------------------------
  __NOTE__("%s\n", "end");
  //-----------------------------------------------------------------------
}
//-------------------------------------------------------------------------
